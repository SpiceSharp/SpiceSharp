using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Collections.Concurrent;

namespace SpiceSharpGenerator
{
    /// <summary>
    /// A receiver for entities.
    /// </summary>
    public class SyntaxReceiver : ISyntaxReceiver
    {
        /// <summary>
        /// Gets the list of eligible entities that may need to be extended using code generation.
        /// </summary>
        /// <value>
        /// The entity classes.
        /// </value>
        public ConcurrentDictionary<ClassDeclarationSyntax, int> Entities { get; } = new ConcurrentDictionary<ClassDeclarationSyntax, int>();

        /// <summary>
        /// Gets a list of behaviors that were tagged with the BehaviorFor attribute.
        /// </summary>
        /// <value>
        /// The behavior classes.
        /// </value>
        public ConcurrentDictionary<ClassDeclarationSyntax, int> Behaviors { get; } = new ConcurrentDictionary<ClassDeclarationSyntax, int>();

        /// <summary>
        /// Gets a list of binding contexts.
        /// </summary>
        /// <value>
        /// The binding context classes.
        /// </value>
        public ConcurrentDictionary<ClassDeclarationSyntax, int> BindingContexts { get; } = new ConcurrentDictionary<ClassDeclarationSyntax, int>();

        /// <summary>
        /// Gets a list of parameter sets.
        /// </summary>
        /// <value>
        /// The parameter sets.
        /// </value>
        public ConcurrentDictionary<ClassDeclarationSyntax, int> ParameterSets { get; } = new ConcurrentDictionary<ClassDeclarationSyntax, int>();

        /// <summary>
        /// Gets a list of parameter sets that need checked properties.
        /// </summary>
        /// <value>
        /// The parameter sets.
        /// </value>
        public ConcurrentDictionary<FieldDeclarationSyntax, int> CheckedFields { get; } = new ConcurrentDictionary<FieldDeclarationSyntax, int>();

        /// <summary>
        /// Collect whatever we need to create generated code later.
        /// </summary>
        /// <param name="syntaxNode">The syntax node.</param>
        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Find out if this node is eligible for creating CreateBehaviors()
            if (syntaxNode is ClassDeclarationSyntax @class)
            {
                foreach (var attribute in @class.AttributeLists.SelectMany(list => list.Attributes))
                {
                    var name = attribute.Name.GetText().ToString();
                    if (IsOneOf(name, "AutoGeneratedBehaviors"))
                        Entities.AddOrUpdate(@class, 1, (c, i) => i + 1);
                    else if (IsOneOf(name, "BehaviorFor"))
                        Behaviors.AddOrUpdate(@class, 1, (c, i) => i + 1);
                    else if (IsOneOf(name, "BindingContextFor"))
                        BindingContexts.AddOrUpdate(@class, 1, (c, i) => i + 1);
                    else if (IsOneOf(name, "GeneratedParameters"))
                        ParameterSets.AddOrUpdate(@class, 1, (c, i) => i + 1);
                }
            }

            // Find properties that are tagged
            if (syntaxNode is FieldDeclarationSyntax field)
            {
                // Only do private ones
                if (field.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword) || m.IsKind(SyntaxKind.ProtectedKeyword)))
                    return;
                foreach (var attribute in field.AttributeLists.SelectMany(list => list.Attributes))
                {
                    var name = attribute.Name.GetText().ToString();
                    if (IsOneOf(name, "GreaterThan", "GreaterThanOrEquals", "LessThan", "LessThanOrEquals",
                        "LowerLimit", "UpperLimit", "ParameterName", "ParameterInfo"))
                    {
                        CheckedFields.AddOrUpdate(field, 1, (f, i) => i + 1);
                    }
                }
            }
        }

        private bool IsOneOf(string name, params string[] attributes)
        {
            if (attributes == null || attributes.Length == 0)
                return false;
            for (var i = 0; i < attributes.Length; i++)
            {
                if (string.CompareOrdinal(name, attributes[i]) == 0)
                    return true;
                if (string.CompareOrdinal(name, $"{attributes[i]}Attribute") == 0)
                    return true;
            }
            return false;
        }
    }
}
