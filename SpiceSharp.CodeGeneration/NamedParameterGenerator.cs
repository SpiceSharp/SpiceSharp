using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace SpiceSharp.CodeGeneration
{
    /// <summary>
    /// A class that can generated methods for setting or getting named parameters
    /// and properties.
    /// </summary>
    public class NamedParameterGenerator : CSharpSyntaxWalker
    {
        /// <summary>
        /// Gets the result.
        /// </summary>
        /// <value>
        /// The result.
        /// </value>
        public CompilationUnitSyntax Result { get; private set; }

        /// <summary>
        /// Gets the generated class count.
        /// </summary>
        /// <value>
        /// The generated class count.
        /// </value>
        public int GeneratedClassCount { get; private set; } = 0;

        private readonly List<BaseTypeSyntax> _baseDefinitions = new List<BaseTypeSyntax>();
        private readonly Dictionary<string, (SyntaxToken Name, TypeSyntax Type, bool HasSetter, bool HasGetter)> _properties
            = new Dictionary<string, (SyntaxToken Name, TypeSyntax Type, bool HasSetter, bool HasGetter)>();

        /// <summary>
        /// Gets the members defined in the class.
        /// </summary>
        /// <value>
        /// The members.
        /// </value>
        public IEnumerable<(SyntaxToken Name, TypeSyntax Type, bool HasSetter, bool HasGetter)> Members
        {
            get
            {
                var done = new HashSet<string>();
                foreach (var property in _properties.Values)
                {
                    if (done.Contains(property.Name.ToString()))
                        continue;
                    done.Add(property.Name.ToString());
                    yield return property;
                }
            }
        }

        /// <inheritdoc/>
        public override void VisitCompilationUnit(CompilationUnitSyntax node)
        {
            Result = CompilationUnit().WithUsings(List(new UsingDirectiveSyntax[] {
                UsingDirective(ParseName("System")),
                UsingDirective(ParseName("System.Collections.Generic")),
                UsingDirective(ParseName("SpiceSharp.ParameterSets")),
                UsingDirective(ParseName("SpiceSharp.Diagnostics"))
            })).WithLeadingTrivia(ParseLeadingTrivia("// This file was automatically generated by SpiceSharp.CodeGeneration" + Environment.NewLine));
            GeneratedClassCount = 0;
            base.VisitCompilationUnit(node);
        }

        /// <inheritdoc/>
        public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
        {
            Result = Result.AddMembers(NamespaceDeclaration(node.Name));
            base.VisitNamespaceDeclaration(node);
        }

        /// <inheritdoc/>
        public override void VisitClassDeclaration(ClassDeclarationSyntax node)
        {
            if (node.Modifiers.Any(SyntaxKind.PartialKeyword) && 
                node.AttributeLists.Any(
                    list => list.Attributes.Any(
                        attr =>  attr.ArgumentList != null &&
                            attr.ArgumentList.Arguments.Any(
                                arg => arg.NameEquals != null && 
                                arg.NameEquals.Name.ToString().Equals("AddNames") && 
                                arg.Expression.ToString().Equals("true")))))
            {
                _baseDefinitions.Clear();
                var cl = ClassDeclaration(
                    List<AttributeListSyntax>(),
                    TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.PartialKeyword)),
                    node.Identifier,
                    null,
                    null,
                    List<TypeParameterConstraintClauseSyntax>(),
                    List<MemberDeclarationSyntax>()
                    )
                    .WithLeadingTrivia(Whitespace(Environment.NewLine))
                    .WithTrailingTrivia(Whitespace(Environment.NewLine));

                base.VisitClassDeclaration(node);

                // Generate our methods now
                cl = cl.WithMembers(List(CreateDictionaryDefinition().Union(CreateMethods())));
                if (_baseDefinitions.Count > 0)
                    cl = cl.WithBaseList(BaseList(SeparatedList(_baseDefinitions)));

                // Replace the first member with our generated class
                if (Result.Members.Count == 0 || !(Result.Members.Last() is NamespaceDeclarationSyntax))
                    Result = Result.AddMembers(cl);
                else
                {
                    var insertion = (NamespaceDeclarationSyntax)Result.Members.Last();
                    while (insertion.Members.Count > 0 && insertion.Members.Last() is NamespaceDeclarationSyntax newInsertion)
                        insertion = newInsertion;
                    Result = Result.ReplaceNode(insertion, insertion.AddMembers(cl));
                }
                GeneratedClassCount++;
            }
        }

        /// <inheritdoc/>
        public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            // Check for any named attribute that we can use
            bool hasGetter = false, hasSetter = false;
            if (node.AccessorList.Accessors.Any(ads => ads.Keyword.ValueText.Equals("get")))
                hasGetter = true;
            if (node.AccessorList.Accessors.Any(ads => ads.Keyword.ValueText.Equals("set")))
                hasSetter = true;
            foreach (var attribute in node
                .AttributeLists
                .SelectMany(al => al.Attributes)
                .Where(attr =>
                {
                    switch (attr.Name.ToString())
                    {
                        case "ParameterName":
                        case "ParameterNameAttribute":
                            return true;
                    }
                    return false;
                }))
            {
                _properties.Add(
                    attribute.ArgumentList.Arguments[0].Expression.WithoutTrivia().ToString(),
                    (node.Identifier.WithoutTrivia(), node.Type.WithoutTrivia(), hasSetter, hasGetter));
            }

            base.VisitPropertyDeclaration(node);
        }

        private MemberDeclarationSyntax[] CreateDictionaryDefinition()
        {
            // Create an enumeration of possible properties/parameters like this:
            /*
             * private enum NamedParameters
             * {
             *      Name1,
             *      Name2,
             *      ...
             * }
             */
            var enumeration = EnumDeclaration(
                List<AttributeListSyntax>(),
                TokenList(Token(SyntaxKind.PrivateKeyword)),
                Identifier("NamedParameters").WithTrailingTrivia(Whitespace(Environment.NewLine)),
                null,
                SeparatedList(
                    Break(_properties.Values
                        .Select(value => value.Name.ToString())
                        .Distinct()
                        .Select(name => EnumMemberDeclaration(name).WithLeadingTrivia(Whitespace(Environment.NewLine)))))
                );

            // Create a dictionary definition that looks like this:
            /*
             * private static readonly Dictionary<string, NamedParameters> _namedMap = new Dictionary<string, NamedParameters>(ReflectionHelper.Comparer)
             * {
             *      { "name1", NamedParameters.Name1 },
             *      { "name2", NamedParameters.Named2 },
             *      ...
             * }
             */

            var expr = ParseExpression("new Variable() { { 1, 2 }, { 3, 4 } }");
            var initializer = EqualsValueClause(
                ObjectCreationExpression(
                    ParseTypeName("Dictionary<string, NamedParameters>"),
                    BreakAfter(ParseArgumentList("(ReflectionHelper.Comparer)")),
                    InitializerExpression(
                        SyntaxKind.CollectionInitializerExpression,
                        SeparatedList<ExpressionSyntax>(
                            Break(
                                _properties.Select(pair =>
                                {
                                    return BreakBefore(InitializerExpression(SyntaxKind.ComplexElementInitializerExpression,
                                        SeparatedList(new[]
                                        {
                                            ParseExpression(pair.Key),
                                            ParseExpression($"NamedParameters.{pair.Value.Name}")
                                        })));
                                }))
                            )
                        )));
            var dictionaryMap = FieldDeclaration(
                List<AttributeListSyntax>(),
                TokenList(
                    Token(SyntaxKind.PrivateKeyword),
                    Token(SyntaxKind.StaticKeyword),
                    Token(SyntaxKind.ReadOnlyKeyword)),
                VariableDeclaration(
                    ParseTypeName("Dictionary<string, NamedParameters>"),
                    SeparatedList(new[] { VariableDeclarator(
                        Identifier("_namedMap"), null, initializer) })
                    )
                );
            return new MemberDeclarationSyntax[] {
                Break(enumeration),
                Break(dictionaryMap)
            };
        }

        private MemberDeclarationSyntax[] CreateMethods()
        {
            // Get all the distinct types
            var types = _properties.Values.Select(value => MapType(value.Type)).Distinct().ToArray();
            var doc = ParseLeadingTrivia(Environment.NewLine + "/// <inheritdoc/>" + Environment.NewLine);

            // Create the SetParameter methods and add interface methods for each type
            /*
             * public void SetParameter(string name, <type> value)
             * public bool TrySetParameter(string name, <type> value)
             * public Func<type> CreateParameterSetter(string name)
             */
            var result = new List<MemberDeclarationSyntax>(types.Length * 6);
            foreach (var type in types)
            {
                // We need the unique members
                var setProperties = Members.Where(value => string.Compare(MapType(value.Type), type) == 0 && value.HasSetter).ToArray();
                var getProperties = Members.Where(value => string.Compare(MapType(value.Type), type) == 0 && value.HasGetter).ToArray();

                if (setProperties.Length > 0)
                {
                    _baseDefinitions.Add(SimpleBaseType(ParseTypeName($"IImportParameterSet<{type}>")));

                    // public void SetParameter(string name, <type> value)
                    var statements = IfStatement(
                        ParseExpression("_namedMap.TryGetValue(name, out var id)"),
                        Break(Block(
                            Break(SwitchStatement(IdentifierName("id"),
                                List(Break(setProperties.Select(value =>
                                    {
                                        return BreakBefore(SwitchSection(
                                            List<SwitchLabelSyntax>(new[]
                                            {
                                            CaseSwitchLabel(ParseExpression($"NamedParameters.{value.Name}"))
                                            }),
                                            List(new StatementSyntax[]
                                            {
                                            ParseStatement($"{value.Name} = value;"),
                                            ParseStatement($"return;")
                                            })));
                                    })))))
                        )));
                    var declaration = (MethodDeclarationSyntax)ParseMemberDeclaration($"void IImportParameterSet<{type}>.SetParameter(string name, {type} value) {{}}");
                    declaration = declaration.ReplaceNode(declaration.Body, Break(Block(
                        Break(statements), 
                        BreakAfter(ParseStatement($"throw new ParameterNotFoundException(this, name, typeof({type}));")))));
                    result.Add(BreakAfter(declaration.WithLeadingTrivia(doc)));

                    // public bool TrySetParameter(string name, <type> value)
                    statements = IfStatement(
                        ParseExpression("_namedMap.TryGetValue(name, out var id)"),
                        Break(Block(
                            Break(SwitchStatement(IdentifierName("id"),
                                List(Break(setProperties.Select(value =>
                                    {
                                        return BreakBefore(SwitchSection(
                                            List<SwitchLabelSyntax>(new[]
                                            {
                                            CaseSwitchLabel(ParseExpression($"NamedParameters.{value.Name}"))
                                            }),
                                            List(new StatementSyntax[]
                                            {
                                            ParseStatement($"{value.Name} = value;"),
                                            ParseStatement("return true;")
                                            })));
                                    })))))
                        )));
                    declaration = (MethodDeclarationSyntax)ParseMemberDeclaration($"bool IImportParameterSet<{type}>.TrySetParameter(string name, {type} value) {{}}");
                    declaration = declaration.ReplaceNode(declaration.Body, Break(Block(
                        Break(statements),
                        BreakAfter(ParseStatement("return false;")))));
                    result.Add(BreakAfter(declaration.WithLeadingTrivia(doc)));

                    // Action<type> CreateParameterSetter(string name)
                    statements = IfStatement(
                        ParseExpression("_namedMap.TryGetValue(name, out var id)"),
                        Break(Block(
                            Break(SwitchStatement(
                                IdentifierName("id"),
                                List(Break(setProperties.Select(value =>
                                    {
                                        return BreakBefore(SwitchSection(
                                            List<SwitchLabelSyntax>(new[]
                                            {
                                                CaseSwitchLabel(ParseExpression($"NamedParameters.{value.Name}"))
                                            }),
                                            List(new StatementSyntax[]
                                            {
                                                ParseStatement($"return value => {value.Name} = value;")
                                            })));
                                    })))))
                        )));
                    declaration = (MethodDeclarationSyntax)ParseMemberDeclaration($"Action<{type}> IImportParameterSet<{type}>.CreateParameterSetter(string name) {{}}");
                    declaration = declaration.ReplaceNode(declaration.Body, Break(Block(
                        Break(statements),
                        BreakAfter(ParseStatement("return null;")))));
                    result.Add(BreakAfter(declaration.WithLeadingTrivia(doc)));
                }

                if (getProperties.Length > 0)
                {
                    _baseDefinitions.Add(SimpleBaseType(ParseTypeName($"IExportPropertySet<{type}>")));

                    // public <type> GetProperty(string name)
                    var statements = IfStatement(
                        ParseExpression("_namedMap.TryGetValue(name, out var id)"),
                        Break(Block(
                            Break(SwitchStatement(IdentifierName("id"),
                                List(Break(getProperties.Select(value =>
                                {
                                    return BreakBefore(SwitchSection(
                                        List<SwitchLabelSyntax>(new[]
                                        {
                                        CaseSwitchLabel(ParseExpression($"NamedParameters.{value.Name}"))
                                        }),
                                        List(new StatementSyntax[]
                                        {
                                        ParseStatement($"return {value.Name};")
                                        })));
                                })))))
                        )));
                    var declaration = (MethodDeclarationSyntax)ParseMemberDeclaration($"{type} IExportPropertySet<{type}>.GetProperty(string name) {{}}");
                    declaration = declaration.ReplaceNode(declaration.Body, Break(Block(
                        Break(statements),
                        BreakAfter(ParseStatement($"throw new ParameterNotFoundException(this, name, typeof({type}));")))));
                    result.Add(BreakAfter(declaration.WithLeadingTrivia(doc)));

                    // public bool TryGetProperty(string name, out <type> value)
                    statements = IfStatement(
                        ParseExpression("_namedMap.TryGetValue(name, out var id)"),
                        Break(Block(
                            Break(SwitchStatement(IdentifierName("id"),
                                List(Break(getProperties.Select(value =>
                                {
                                    return BreakBefore(SwitchSection(
                                        List<SwitchLabelSyntax>(new[]
                                        {
                                            CaseSwitchLabel(ParseExpression($"NamedParameters.{value.Name}"))
                                        }),
                                        List(new StatementSyntax[]
                                        {
                                            ParseStatement("isValid = true;"),
                                            ParseStatement($"return {value.Name};")
                                        })));
                                })))))
                        )));
                    declaration = (MethodDeclarationSyntax)ParseMemberDeclaration($"{type} IExportPropertySet<{type}>.TryGetProperty(string name, out bool isValid) {{}}");
                    declaration = declaration.ReplaceNode(declaration.Body, Break(Block(
                        Break(statements),
                        BreakAfter(ParseStatement("isValid = false;")),
                        BreakAfter(ParseStatement("return default;")))));
                    result.Add(BreakAfter(declaration.WithLeadingTrivia(doc)));

                    // Func<type> CreatePropertyGetter(string name)
                    statements = IfStatement(
                        ParseExpression("_namedMap.TryGetValue(name, out var id)"),
                        Break(Block(
                            Break(SwitchStatement(
                                IdentifierName("id"),
                                List(Break(getProperties.Select(value =>
                                {
                                    return BreakBefore(SwitchSection(
                                        List<SwitchLabelSyntax>(new[]
                                        {
                                                CaseSwitchLabel(ParseExpression($"NamedParameters.{value.Name}"))
                                        }),
                                        List(new StatementSyntax[]
                                        {
                                                ParseStatement($"return () => {value.Name};")
                                        })));
                                })))))
                        )));
                    declaration = (MethodDeclarationSyntax)ParseMemberDeclaration($"Func<{type}> IExportPropertySet<{type}>.CreatePropertyGetter(string name) {{}}");
                    declaration = declaration.ReplaceNode(declaration.Body, Break(Block(
                        Break(statements),
                        BreakAfter(ParseStatement("return null;")))));
                    result.Add(BreakAfter(declaration.WithLeadingTrivia(doc)));
                }
            }

            return result.ToArray();
        }

        private static T BreakAfter<T>(T node) where T : SyntaxNode => node?.WithTrailingTrivia(Whitespace(Environment.NewLine));

        private static T BreakBefore<T>(T node) where T : SyntaxNode => node?.WithLeadingTrivia(Whitespace(Environment.NewLine));

        private static T Break<T>(T node) where T : SyntaxNode
            => node?
            .WithLeadingTrivia(Whitespace(Environment.NewLine))
            .WithTrailingTrivia(Whitespace(Environment.NewLine));

        private static IEnumerable<T> Break<T>(IEnumerable<T> node) where T : SyntaxNode
        {
            var arr = node?.ToArray();
            if (arr != null && arr.Length > 0)
            {
                arr[0] = arr[0].WithLeadingTrivia(Whitespace(Environment.NewLine));
                arr[arr.Length - 1] = arr[arr.Length - 1].WithTrailingTrivia(Whitespace(Environment.NewLine));
            }
            return arr;
        }

        private static string MapType(TypeSyntax type)
        {
            if (type is GenericNameSyntax gns)
            {
                if (gns.Identifier.ValueText.Equals("GivenParameter"))
                    return gns.TypeArgumentList.Arguments[0].ToString();
            }
            return type.ToString();
        }
    }
}
