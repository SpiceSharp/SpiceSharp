using System;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Formatting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;

namespace SpiceSharp.CodeGeneration
{
    /// <summary>
    /// A document.
    /// </summary>
    public class Document
    {
        private readonly CompilationUnitSyntax _unit;
        private readonly ClassGenerationFinder _generated;

        /// <summary>
        /// The backup path
        /// </summary>
        public string BackupPath { get; set; } = @"backup";

        /// <summary>
        /// Initializes a new instance of the <see cref="Document"/> class.
        /// </summary>
        /// <param name="filename">The filename.</param>
        public Document(string filename)
        {
            using var sr = new StreamReader(filename);

            _unit = SyntaxFactory.ParseCompilationUnit(sr.ReadToEnd());
            _generated = new ClassGenerationFinder();
            _generated.Visit(_unit);
        }

        /// <summary>
        /// Checks if this file should be processed.
        /// </summary>
        public bool ShouldGenerate => _generated.GeneratedClasses.Count > 0;

        /// <summary>
        /// Exports to the specified filename.
        /// </summary>
        /// <param name="filename">The filename.</param>
        public void Export(string filename)
        {
            var rw = new ClassRewriter();

            var result = _unit;
            foreach (var c in _generated.GeneratedClasses)
                result = _unit.ReplaceNode(c, rw.Visit(c));

            using (var ws = new AdhocWorkspace())
            {
                var options = ws.Options
                    .WithChangedOption(CSharpFormattingOptions.WrappingKeepStatementsOnSingleLine, false)
                    .WithChangedOption(CSharpFormattingOptions.WrappingPreserveSingleLine, true);
                result = (CompilationUnitSyntax)Formatter.Format(result, ws, options);
            }

            using (var sw = new StreamWriter(filename))
            {
                // Let's leave a message if the parsed result changed in any significant way
                if (!_unit.Equals(result))
                    Console.WriteLine($"Applying changes to \"{filename}\"");
                else
                    // No need to rewrite this file
                    return;

                // Keep a backup of the file
                string backup = null;
                foreach (var member in _unit.Members)
                {
                    if (member is NamespaceDeclarationSyntax nds && nds.Members.FirstOrDefault() is ClassDeclarationSyntax cds)
                        backup = nds.Name.ToString() + "." + cds.Identifier.ToString() + ".cs";
                }

                backup = Path.Combine(BackupPath, backup);
                if (backup != null && !File.Exists(backup))
                {
                    // Write the backup file first
                    if (!Directory.Exists(BackupPath))
                        Directory.CreateDirectory(BackupPath);
                    using (var sw_backup = new StreamWriter(backup))
                        sw_backup.Write(_unit.ToFullString());

                    // Then the autogenerated file
                    sw.Write(result.ToFullString());
                }
                else
                    Console.WriteLine("Could not make a backup, skipped generation of " + Path.GetFileName(filename));
            }
        }
    }
}
