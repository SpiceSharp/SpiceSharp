using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Formatting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using System;
using System.IO;
using System.Linq;

namespace SpiceSharp.CodeGeneration
{
    /// <summary>
    /// A document.
    /// </summary>
    public class Document
    {
        private readonly CompilationUnitSyntax _unit;
        private readonly ClassGenerationFinder _generated;

        /// <summary>
        /// The backup path
        /// </summary>
        public string BackupPath { get; set; } = @"backup";

        /// <summary>
        /// Initializes a new instance of the <see cref="Document"/> class.
        /// </summary>
        /// <param name="filename">The filename.</param>
        public Document(string filename)
        {
            using var sr = new StreamReader(filename);

            _unit = SyntaxFactory.ParseCompilationUnit(sr.ReadToEnd());
            _generated = new ClassGenerationFinder();
            _generated.Visit(_unit);
        }

        /// <summary>
        /// Gets a value indicating whether things can be generated.
        /// </summary>
        /// <value>
        ///   <c>true</c> if code should be generated; otherwise, <c>false</c>.
        /// </value>
        public bool ShouldGenerate => _generated.GeneratedClasses.Count > 0;

        /// <summary>
        /// Exports to the specified filename.
        /// </summary>
        /// <param name="filename">The filename.</param>
        public void Export(string filename)
        {
            // Replace setters and getters
            {
                var rw = new PropertyRuleGenerator();
                SyntaxNode result = _unit;
                foreach (var c in _generated.GeneratedClasses.Where(g => g.AddRules))
                    result = result.ReplaceNode(c.Class, rw.Visit(c.Class));
                result = Format(result);
                if (string.CompareOrdinal(_unit.ToFullString(), result.ToFullString()) != 0)
                {
                    // Only export if the file changed in any meaningful way
                    Console.WriteLine($"Applying changes to \"{filename}\"");
                    ExportFile(filename, result);
                }
            }

            // Extend the class with generated setters and getters
            {
                if (_generated.GeneratedClasses.Any(g => g.AddNames))
                {
                    var rw = new NamedParameterGenerator();
                    rw.Visit(_unit);

                    var result = Format(rw.Result);
                    string original = null;
                    var namedFile = Path.Combine(Path.GetDirectoryName(filename), $"{Path.GetFileNameWithoutExtension(filename)}.Named.cs");
                    if (File.Exists(namedFile))
                    {
                        using var sr = new StreamReader(namedFile);
                        original = sr.ReadToEnd();
                    }
                    if (string.CompareOrdinal(result.ToFullString(), original) != 0)
                    {
                        // Only export if the file changed in a meaningful way
                        Console.WriteLine($"Applying changes to \"{namedFile}\"");
                        ExportFile(namedFile, result);
                    }
                }
            }
        }

        private SyntaxNode Format(SyntaxNode code)
        {
            SyntaxNode result;
            using (var ws = new AdhocWorkspace())
            {
                var options = ws.Options
                    .WithChangedOption(CSharpFormattingOptions.WrappingKeepStatementsOnSingleLine, false)
                    .WithChangedOption(CSharpFormattingOptions.WrappingPreserveSingleLine, true);
                result = Formatter.Format(code, ws, options);
            }
            return result;
        }

        private void ExportFile(string filename, SyntaxNode code)
        {
            // Keep a backup of the file
            string backup = null;
            foreach (var member in _unit.Members)
            {
                if (member is NamespaceDeclarationSyntax nds && nds.Members.FirstOrDefault() is ClassDeclarationSyntax cds)
                    backup = nds.Name.ToString() + "." + cds.Identifier.ToString() + ".cs";
            }

            backup = backup != null ? Path.Combine(BackupPath, backup) : null;
            if (backup != null && !File.Exists(backup))
            {
                // Write the backup file first
                if (!Directory.Exists(BackupPath))
                    Directory.CreateDirectory(BackupPath);
                using var sw_backup = new StreamWriter(backup);
                sw_backup.Write(_unit.ToFullString());
            }
            else
                Console.WriteLine("Could not make a backup, skipped generation of " + Path.GetFileName(filename));

            // Then the autogenerated file
            using var sw = new StreamWriter(filename);
            sw.Write(code.ToFullString());
        }
    }
}
