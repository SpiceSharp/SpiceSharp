using System;
using SpiceSharp.Algebra.Solve;

namespace SpiceSharp.Algebra
{
    /// <summary>
    /// A base class for sparse linear systems that can be solved using LU decomposition.
    /// Pivoting is controlled by the <see cref="Strategy"/> property. The implementation
    /// is optimized for sparse matrices through the <see cref="ISparseMatrix{T}"/> interface.
    /// </summary>
    /// <typeparam name="M">The matrix type.</typeparam>
    /// <typeparam name="V">The right-hand side vector type.</typeparam>
    /// <typeparam name="T">The base value type.</typeparam>
    public abstract partial class SparseLUSolver<M, V, T> : LinearSystem<M, V, T>, ISparseSolver<T>
        where M : IPermutableMatrix<T>, ISparseMatrix<T>
        where V : IPermutableVector<T>, ISparseVector<T>
        where T : IFormattable, IEquatable<T>
    {
        /// <summary>
        /// Gets or sets the degeneracy of the matrix. For example, specifying 1 will let the solver know that one equation is
        /// expected to be linearly dependent on the others.
        /// </summary>
        /// <value>
        /// The degeneracy.
        /// </value>
        /// <exception cref="ArgumentException">Thrown if the order reduction is negative.</exception>
        public int Degeneracy
        {
            get => _order;
            set
            {
                if (value < 0)
                    throw new ArgumentException(Properties.Resources.Algebra_InvalidOrder);
                _order = value;
            }
        }
        private int _order = 0;

        /// <summary>
        /// Gets or sets the region for reordering the matrix. For example, specifying 1 will avoid a pivot from being chosen from
        /// the last row or column.
        /// </summary>
        /// <value>
        /// The pivot search reduction.
        /// </value>
        /// <exception cref="ArgumentException">Thrown if the pivot search reduction is negative.</exception>
        public int PivotSearchReduction
        {
            get => _search;
            set
            {
                if (value < 0)
                    throw new ArgumentException(Properties.Resources.Algebra_InvalidPivotSearchReduction);
                _search = value;
            }
        }
        private int _search = 0;

        /// <summary>
        /// Number of fill-ins in the matrix generated by the solver.
        /// </summary>
        /// <remarks>
        /// Fill-ins are elements that were auto-generated as a consequence
        /// of the solver trying to solve the matrix. To save memory, this
        /// number should remain small.
        /// </remarks>
        public int Fillins { get; private set; }

        /// <summary>
        /// Gets or sets a flag that reordering is required.
        /// </summary>
        /// <remarks>
        /// If true, the method <see cref="OrderAndFactor"/> will first try to factor a part of the matrix without
        /// reordering. This can save some time if we don't expect significant changes by the solver.
        /// </remarks>
        public bool NeedsReordering { get; set; }

        /// <summary>
        /// Gets whether or not the solver is factored.
        /// </summary>
        /// <value>
        ///   <c>true</c> if this instance is factored; otherwise, <c>false</c>.
        /// </value>
        public bool IsFactored { get; protected set; }

        /// <summary>
        /// Gets the pivoting strategy being used.
        /// </summary>
        /// <value>
        /// The pivoting strategy.
        /// </value>
        public SparsePivotStrategy<T> Strategy { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SparseLUSolver{M, V, T}"/> class.
        /// </summary>
        /// <param name="matrix">The matrix.</param>
        /// <param name="vector">The vector.</param>
        /// <param name="strategy">The pivoting strategy that needs to be used.</param>
        protected SparseLUSolver(M matrix, V vector, SparsePivotStrategy<T> strategy)
            : base(matrix, vector)
        {
            IsFactored = false;
            NeedsReordering = true;
            Strategy = strategy.ThrowIfNull(nameof(strategy));
            Fillins = 0;
        }

        /// <summary>
        /// Preconditions the specified method.
        /// </summary>
        /// <param name="method">The method.</param>
        public virtual void Precondition(PreconditionMethod<T> method)
        {
            bool _isFirstSwap = true;
            void OnMatrixRowsSwapped(object sender, PermutationEventArgs args)
            {
                // Reflect the swapped vector elements in the row translation
                if (_isFirstSwap)
                {
                    _isFirstSwap = false;
                    Row.Swap(args.Index1, args.Index2);
                    Vector.SwapElements(args.Index1, args.Index2);
                    _isFirstSwap = true;
                }
            }
            void OnMatrixColumnsSwapped(object sender, PermutationEventArgs args)
            {
                // Reflect the swapped matrix column in the column translation
                Column.Swap(args.Index1, args.Index2);
            }
            void OnVectorElementsSwapped(object sender, PermutationEventArgs args)
            {
                // Reflect the swapped vector elements in the row translation
                if (_isFirstSwap)
                {
                    _isFirstSwap = false;
                    Row.Swap(args.Index1, args.Index2);
                    Matrix.SwapRows(args.Index1, args.Index2);
                    _isFirstSwap = true;
                }
            }

            Matrix.RowsSwapped += OnMatrixRowsSwapped;
            Matrix.ColumnsSwapped += OnMatrixColumnsSwapped;
            Vector.ElementsSwapped += OnVectorElementsSwapped;
            method(Matrix, Vector);
            Matrix.RowsSwapped -= OnMatrixRowsSwapped;
            Matrix.ColumnsSwapped -= OnMatrixColumnsSwapped;
            Vector.ElementsSwapped -= OnVectorElementsSwapped;
        }

        /// <summary>
        /// Solves the equations using the Y-matrix and Rhs-vector.
        /// </summary>
        /// <param name="solution">The solution.</param>
        public abstract void Solve(IVector<T> solution);

        /// <summary>
        /// Solves the equations using the transposed Y-matrix.
        /// </summary>
        /// <param name="solution">The solution.</param>
        public abstract void SolveTransposed(IVector<T> solution);

        /// <summary>
        /// Factor the Y-matrix and Rhs-vector.
        /// </summary>
        /// <returns>
        /// <c>true</c> if the factoring was successful; otherwise <c>false</c>.
        /// </returns>
        public bool Factor()
        {
            IsFactored = false;
            var order = Size - _order;
            for (var step = 1; step <= order; step++)
            {
                var pivot = Matrix.FindDiagonalElement(step);

                // We don't consult the pivoting strategy, we just need to know if we can eliminate this row
                if (pivot == null || pivot.Value.Equals(default))
                    return false;
                Eliminate(Matrix.FindDiagonalElement(step));
            }
            IsFactored = true;
            return true;
        }

        /// <summary>
        /// Order and factor the Y-matrix and Rhs-vector.
        /// This method will reorder the matrix as it sees fit.
        /// </summary>
        /// <returns>
        /// The number of rows that were successfully eliminated.
        /// </returns>
        public int OrderAndFactor()
        {
            IsFactored = false;
            int step = 1;
            var order = Size - Degeneracy;
            Strategy.PivotSearchReduction = PivotSearchReduction;
            if (!NeedsReordering)
            {
                // Matrix has been factored before, and reordering is not required
                for (step = 1; step <= order; step++)
                {
                    var pivot = Matrix.FindDiagonalElement(step);
                    if (Strategy.IsValidPivot(pivot))
                        Eliminate(pivot);
                    else
                    {
                        NeedsReordering = true;
                        break;
                    }
                }

                if (!NeedsReordering)
                {
                    IsFactored = true;
                    return order;
                }
            }

            // Setup the pivot strategy
            Strategy.Setup(Matrix, Vector, step);

            for (; step <= order; step++)
            {
                var pivot = Strategy.FindPivot(Matrix, step);
                if (pivot == null)
                    return step - 1;
                MovePivot(pivot, step);
                Eliminate(pivot);
            }

            IsFactored = true;
            NeedsReordering = false;
            return order;
        }

        /// <summary>
        /// Eliminates the matrix right and below the pivot.
        /// </summary>
        /// <param name="pivot">The pivot element.</param>
        /// <returns>
        /// <c>true</c> if the elimination was successful; otherwise <c>false</c>.
        /// </returns>
        protected abstract void Eliminate(ISparseMatrixElement<T> pivot);

        /// <summary>
        /// Finds the diagonal element at the specified row/column.
        /// </summary>
        /// <param name="index">The row/column index.</param>
        /// <returns>
        /// The matrix element.
        /// </returns>
        public Element<T> FindDiagonalElement(int index)
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException(nameof(index));
            if (index > Size)
                return null;
            int row = Row[index];
            int column = Column[index];
            return Matrix.FindElement(row, column);
        }

        /// <summary>
        /// Finds the element at the specified position in the matrix.
        /// </summary>
        /// <param name="row">The row index.</param>
        /// <param name="column">The column index.</param>
        /// <returns>
        /// The element if it exists; otherwise <c>null</c>.
        /// </returns>
        public Element<T> FindElement(int row, int column)
        {
            if (row < 0)
                throw new ArgumentOutOfRangeException(nameof(row));
            if (column < 0)
                throw new ArgumentOutOfRangeException(nameof(column));
            if (row > Size || column > Size)
                return null;
            row = Row[row];
            column = Column[column];
            return Matrix.FindElement(row, column);
        }

        /// <summary>
        /// Finds the element at the specified position in the right-hand side vector.
        /// </summary>
        /// <param name="row">The row index.</param>
        /// <returns>
        /// The element if it exists; otherwise <c>null</c>.
        /// </returns>
        public Element<T> FindElement(int row)
        {
            row = Row[row];
            return Vector.FindElement(row);
        }

        /// <summary>
        /// Gets the element at the specified position in the matrix. A new element is
        /// created if it doesn't exist yet.
        /// </summary>
        /// <param name="row">The row index.</param>
        /// <param name="column">The column index.</param>
        /// <returns>
        /// The matrix element.
        /// </returns>
        public Element<T> GetElement(int row, int column)
        {
            row = Row[row];
            column = Column[column];
            var elt = Matrix.GetElement(row, column);

            // If we created a new row or column, let's move it back to still have the same equations as linearly dependent
            if (Degeneracy > 0)
            {
                if (row == Size)
                    SwapRows(Size, Size - Degeneracy);
                if (column == Size)
                    SwapColumns(Size, Size - Degeneracy);
            }
            return elt;
        }

        /// <summary>
        /// Gets the element at the specified position in the right-hand side vector.
        /// A new element is created if it doesn't exist yet.
        /// </summary>
        /// <param name="row">The row.</param>
        /// <returns>
        /// The vector element.
        /// </returns>
        public Element<T> GetElement(int row)
        {
            if (row < 0)
                throw new ArgumentOutOfRangeException(nameof(row));
            row = Row[row];
            var elt = Vector.GetElement(row);

            // If we created a new row, let's move it backto still have the same equations as linearly dependent
            if (Degeneracy > 0)
            {
                if (row == Size)
                    SwapRows(Size, Size - Degeneracy);
            }
            return elt;
        }

        /// <summary>
        /// Move a chosen pivot to the diagonal.
        /// </summary>
        /// <param name="pivot">The pivot element.</param>
        /// <param name="step">The current step of factoring.</param>
        protected void MovePivot(ISparseMatrixElement<T> pivot, int step)
        {
            pivot.ThrowIfNull(nameof(pivot));
            Strategy.MovePivot(Matrix, Vector, pivot, step);

            // Move the pivot in the matrix
            SwapRows(pivot.Row, step);
            SwapColumns(pivot.Column, step);

            // Update the pivoting strategy
            Strategy.Update(Matrix, pivot, step);
        }

        /// <summary>
        /// Creates a fill-in element.
        /// </summary>
        /// <param name="row">The row index.</param>
        /// <param name="column">The column index.</param>
        /// <returns>The created element.</returns>
        protected virtual ISparseMatrixElement<T> CreateFillin(int row, int column)
        {
            var result = (ISparseMatrixElement<T>)Matrix.GetElement(row, column);
            Strategy.CreateFillin(Matrix, result);
            Fillins++;
            return result;
        }

        /// <summary>
        /// Resets all elements in the matrix.
        /// </summary>
        public override void ResetMatrix()
        {
            base.ResetMatrix();
            IsFactored = false;
        }

        /// <summary>
        /// Clears the system of any elements. The size of the system becomes 0.
        /// </summary>
        public override void Clear()
        {
            base.Clear();
            IsFactored = false;
            NeedsReordering = true;
            Fillins = 0;
            Strategy.Clear();
        }
    }
}
