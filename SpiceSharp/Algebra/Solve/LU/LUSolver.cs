using System;
using SpiceSharp.Algebra.Solve;

// ReSharper disable once CheckNamespace
namespace SpiceSharp.Algebra
{
    /// <summary>
    /// A base class for linear systems that can be solved using LU decomposition.
    /// Pivoting is controlled by the <see cref="Strategy"/> property.
    /// </summary>
    /// <typeparam name="T">The base value type.</typeparam>
    public abstract partial class LUSolver<T> : LinearSystem<T>, ISolver<T> where T : IFormattable, IEquatable<T>
    {
        /// <summary>
        /// Number of fill-ins in the matrix generated by the solver.
        /// </summary>
        /// <remarks>
        /// Fill-ins are elements that were auto-generated as a consequence
        /// of the solver trying to solve the matrix. To save memory, this
        /// number should remain small.
        /// </remarks>
        public int Fillins { get; private set; }

        /// <summary>
        /// Gets or sets a flag that reordering is required.
        /// </summary>
        /// <remarks>
        /// Can be used by the pivoting strategy to indicate that a reordering is required.
        /// </remarks>
        public bool NeedsReordering { get; set; }

        /// <summary>
        /// Gets whether or not the solver is factored.
        /// </summary>
        public bool IsFactored { get; protected set; }

        /// <summary>
        /// Gets the pivoting strategy being used.
        /// </summary>
        public PivotStrategy<T> Strategy { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="LUSolver{T}"/> class.
        /// </summary>
        /// <param name="strategy">The pivot strategy that needs to be used.</param>
        protected LUSolver(PivotStrategy<T> strategy)
        {
            NeedsReordering = true;
            Strategy = strategy.ThrowIfNull(nameof(strategy));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="LUSolver{T}"/> class.
        /// </summary>
        /// <param name="strategy">The pivot strategy that needs to be used.</param>
        /// <param name="size">The number of equations/variables.</param>
        protected LUSolver(PivotStrategy<T> strategy, int size)
            : base(size)
        {
            NeedsReordering = true;
            Strategy = strategy.ThrowIfNull(nameof(strategy));
        }

        /// <summary>
        /// Preconditions the current matrix and vector.
        /// </summary>
        /// <param name="method">The preconditioning method.</param>
        public void Precondition(PreconditionMethod<T> method)
        {
            method.ThrowIfNull(nameof(method));
            var matrix = new LinearSystemMatrix(this);
            var vector = new LinearSystemVector(this);
            method(matrix, vector);
        }

        /// <summary>
        /// Solve the system of equations.
        /// </summary>
        /// <param name="solution">The solution vector that will hold the solution to the set of equations.</param>
        public abstract void Solve(IVector<T> solution);

        /// <summary>
        /// Solve the transposed problem.
        /// </summary>
        /// <param name="solution">The solution vector that will hold the solution to the transposed set of equations.</param>
        public abstract void SolveTransposed(IVector<T> solution);

        /// <summary>
        /// Factor the matrix.
        /// </summary>
        /// <returns>True if factoring was successful.</returns>
        public abstract bool Factor();

        /// <summary>
        /// Order and factor the matrix.
        /// </summary>
        public abstract void OrderAndFactor();

        /// <summary>
        /// Move a chosen pivot to the diagonal.
        /// </summary>
        /// <param name="pivot">The pivot element.</param>
        /// <param name="step">The current step of factoring.</param>
        public void MovePivot(IMatrixElement<T> pivot, int step)
        {
            pivot.ThrowIfNull(nameof(pivot));
            Strategy.MovePivot(Matrix, Vector, pivot, step);

            // Move the pivot in the matrix
            var row = pivot.Row;
            var column = pivot.Column;
            if (row != step)
                SwapRows(row, step);
            if (column != step)
                SwapColumns(column, step);

            // Update the pivoting strategy
            Strategy.Update(Matrix, pivot, step);
        }

        /// <summary>
        /// Create a fill-in element.
        /// </summary>
        /// <param name="row">The row index.</param>
        /// <param name="column">The column index.</param>
        /// <returns>The created element.</returns>
        protected virtual IMatrixElement<T> CreateFillin(int row, int column)
        {
            var result = Matrix.GetMatrixElement(row, column);
            Strategy.CreateFillin(Matrix, result);
            Fillins++;
            return result;
        }

        /// <summary>
        /// Resets all elements in the matrix.
        /// </summary>
        public override void ResetMatrix()
        {
            base.ResetMatrix();
            IsFactored = false;
        }

        /// <summary>
        /// Maps an external row/column tuple to an internal one.
        /// </summary>
        /// <param name="indices">The external row/column indices.</param>
        /// <returns>
        /// The internal row/column indices.
        /// </returns>
        public Tuple<int, int> ExternalToInternal(Tuple<int, int> indices)
        {
            return Tuple.Create(Row[indices.Item1], Column[indices.Item2]);
        }

        /// <summary>
        /// Maps an internal row/column tuple to an external one.
        /// </summary>
        /// <param name="indices">The internal row/column indices.</param>
        /// <returns>
        /// The external row/column indices.
        /// </returns>
        public Tuple<int, int> InternalToExternal(Tuple<int, int> indices)
        {
            return Tuple.Create(Row.Reverse(indices.Item1), Column.Reverse(indices.Item2));
        }
    }
}
